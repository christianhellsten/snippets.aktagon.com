<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Golang Worker Pattern Example</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,900;1,900&amp;display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/destyle.css@4.0.0/destyle.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
    <header class="flex">
        <h1 class="fadeout">Golang Worker Pattern Example</h1>
    </header>
    <main>
        <section class="flex">
            <div class="flex-item flex-100">
                <div class="code">An example of the worker pattern in Go.

Executes, e.g., 20 units of work with 20 workers, taking 2 seconds each, in 2 seconds.

```go
package main

//
// $ go build worker.go && WORKERS=20 JOBS=20 ./worker
//
import (
 "fmt"
 "os"
 "strconv"
 "sync"
 "time"
)

// A unit of work
type Rabbit struct {
 ID   int
 Name string
}

// The worker accepting a unit of work
type RabbitWork struct {
 Rabbit Rabbit
}

func main() {
 jobCount, _ := 	strconv.Atoi(os.Getenv("JOBS"))
 workerCount, _ := 	strconv.Atoi(os.Getenv("WORKERS"))
 start := time.Now()
 workers := make(chan RabbitWork, workers)
 var wg sync.WaitGroup

 // Add  workers to our startup "Icarus"
 for i := 0; i < workerCount; i++ {
  wg.Add(1)
  go func() {
   for work := range workers {
    // do some work on data
    var rabbit = work.Rabbit
    fmt.Println("Capturing", rabbit.Name, "(", rabbit.ID, ")")
    time.Sleep(2 * time.Second)
    fmt.Println("Skinned", rabbit.Name, "(", rabbit.ID, ")")
   }
   wg.Done()
  }()
 }

 // Give some work to the workers
 for i := 1; i <= jobCount; i++ {
  workers <- RabbitWork{
   Rabbit: Rabbit{Name: "Toffe", ID: i},
  }
 }

 // Wait for workers to do their job
 close(workers)
 wg.Wait()
 fmt.Println("Work took", time.Since(start).Seconds(), "seconds")
}
```
    

Notes
-----

1. WaitGroup waits for all work to finish
2. wg.Wait() blocks until wg.Done() is called 20 times
3. workers <- RabbitWork will block if all 20 workers are busy working
4. for data := range tasks iterates over incoming work sent through the tasks channel
5. close(workers) closes the channel
6. 40 units of work with 20 workers will complete in 4 seconds
7. also see: <http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/>
</div>
            </div>
        </section>
    </main>
    <footer class="flex">
        <p>&copy; 2023 Aktagon Ltd.</p>
        <a href="https:://aktagon.com">Aktagon Ltd.</a>
        <a href="">Fork me &hearts;</a>
    </footer>
    <script>
        marked.setOptions({
          gfm: true,
          breaks: true,
          highlight: function(code, lang) {
            const language = hljs.getLanguage(lang) ? lang : 'plaintext';
            return hljs.highlight(code, { language }).value;
          },
        });
        const elements = document.getElementsByClassName('code')
        for (var element of elements) {
          element.innerHTML = marked.parse(element.innerHTML);
          console.debug("Rendered element");
        };
    </script>
</body>
</html>
